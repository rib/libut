/*
 * libut - Userspace Tracing Toolkit
 *
 * Copyright (C) 2018 Robert Bragg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * XXX: DON'T EDIT THE WRAPPERS - GENERATED BY gen_api_wrappers.py
 *
 */

#define _GNU_SOURCE
#include <sys/types.h>
#include <dlfcn.h>

#include <stddef.h>
#include <stdbool.h>
#include <string.h>

#include "ut.h"

#define unlikely(x) __builtin_expect(x, 0)

void (*ut_push_task_ptr)(struct ut_task_desc *task_desc);
void (*ut_pop_task_ptr)(struct ut_task_desc *task_desc);

/* Provided so libut has a way to lookup the RTLD_NEXT
 * symbol - relative to these wrappers - to be able to
 * bypass the tracing (to avoid recursion)
 */
void *
ut_dlsym_next_untraced(const char *sym)
{
    return dlsym(RTLD_NEXT, sym);
}

/* XXX: note we aren't using a pthread_once_t but it's fine
 * have a race here since the result will be the same if
 * repeated.
 */
void
load_libut(void)
{
    void *handle = dlopen("libut.so", RTLD_LAZY);
    if (handle) {
        ut_push_task_ptr = dlsym(handle, "ut_push_task");
        ut_pop_task_ptr = dlsym(handle, "ut_pop_task");
    }
}

/* Tricky cases to handle, like dlsym using calloc */
#if 0
/* dlsym uses calloc, so to break the recursion we need a temporary fallback */
static uint8_t tmp_calloc_heap[4096];
static size_t tmp_calloc_off;

void *ut_untraced_malloc(size_t size);
void *ut_untraced_realloc(void * ptr, size_t size);
void ut_untraced_free(void * ptr);

void *
malloc(size_t size)
{
    static struct ut_task_desc task_desc = {
        .name = "malloc"
    };
    void * ret;

    ut_push_task(&task_desc);
    ret = ut_untraced_malloc(size);
    ut_pop_task(&task_desc);

    return ret;
}

void
free(void * ptr)
{
    static struct ut_task_desc task_desc = {
        .name = "free"
    };

    ut_push_task(&task_desc);
    ut_untraced_free(ptr);
    ut_pop_task(&task_desc);
}

void *
tmp_malloc_zeroed(size_t size)
{
    uint8_t *ret = tmp_calloc_heap + tmp_calloc_off;

    if (tmp_calloc_off >= sizeof(tmp_calloc_heap))
        return NULL;

    tmp_calloc_off = (tmp_calloc_off + size + 7) & ~0x7;

    return ret;
}

void *
calloc(size_t nmemb, size_t size)
{
    static void *(*real_calloc)(size_t nmemb, size_t size);
    static bool in_dlsym;
    static struct ut_task_desc task_desc = {
        .name = "calloc"
    };
    void * ret;

    /* XXX: calloc causes trouble becuse it's used by dlsym */
    if (unlikely(!real_calloc)) {
        if (!in_dlsym) {
            in_dlsym = true;
            real_calloc = dlsym(RTLD_NEXT, "calloc");
            in_dlsym = false;
        } else
            return tmp_malloc_zeroed(nmemb * size);
    } else {
        ut_push_task(&task_desc);
        ret = real_calloc(nmemb, size);
        ut_pop_task(&task_desc);
    }

    return ret;
}

void *
realloc(void * ptr, size_t size)
{
    static struct ut_task_desc task_desc = {
        .name = "realloc"
    };
    void * ret;

    ut_push_task(&task_desc);
    ret = ut_untraced_realloc(ptr, size);
    ut_pop_task(&task_desc);

    return ret;
}
#endif
